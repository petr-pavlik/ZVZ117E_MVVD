# Grafický výstup {#sec-grafy}

::: callout-warning
## Cíle cvičení

  - Naučit se tvorbu základních typů grafů.
  - Definovat rozdělení sazby výstupu do polí.
  - Uložit výstupy do souboru.
:::

V R dnes existují dva rúzné systémy pro tvorbu diagramů. První je obsažen v balíčku
`base` a druhý staví na funkcionalitě obsažené v `grid`. V tomto kurzu budeme pracovat
s `base`.

Opět připravíme datovou sadu, tentokrát umístíme do `data.frame` jménem `dfr`.

```{r}
dfr <- data.frame(
  X = 1:100,
  Y = rnorm(100) # <1>
)
```
1. K vytvoření proměnné $Y$ použijeme generování čísel z náhodného rozdělení s parametry $\mu = 0$ a $\sigma = 1$; více v @sec-rozdeleni


::: callout-tip
## Úloha

  1. Zadejte do konzole `demo(graphics)` a projeďte až na konec ukázky. Potom vyčistěte
  panely **Environment**, **Plots** a **Console**. \
  2. Pročtěte si nápovědu `?par`
:::

## Funkce `curve()`

Curve je funkce, která se uplatní při tvorbě symbolických grafů matematických funkcí, kdy není třeba parametrizovat argument `x`. 

```{r, fig.align='center'}
curve(expr = tanh(x),
      from = -pi, 
      to = pi)
```


## Funkce `plot()`

`plot(x, y, ...)` je základní **S3 generická** funkce, jejíž metody umožňují použití na široké množství objektů.
Začneme s použitím na vektor z datasetu `dfr`.

```{r, fig.align='center'}
plot(dfr$Y) # <1> 
```
1. Funkce má věšinu svých argumentů parametrizovaných v přednastavenými hodnotami, nebo hodnotami novodvozenými od parametru. Vidíme tak, že osa $y$ je pojmenována po vstupním parametru. V celém znění funkce vypadá následovně:~~~
plot(x, y = NULL, type = "p",  xlim = NULL, ylim = NULL,
     log = "", main = NULL, sub = NULL, xlab = NULL, ylab = NULL,
     ann = par("ann"), axes = TRUE, frame.plot = axes,
     panel.first = NULL, panel.last = NULL, asp = NA,
     xgap.axis = NA, ygap.axis = NA,
     ...)
~~~

```{r, fig.align='center'}
plot(x = dfr$X, # <1>
     y = dfr$Y, # <1>
     type = "b", # <2>
     col = "gray10", # <3>
     pch = 21, # <4>
     bg = "#4a6777", # <5>
     ylim = c(-abs(1.25 * min(dfr$Y)), # <6>
              1.25 * max(dfr$Y)), # <6>
     xlab = "", # <7>
     ylab = "Value", # <7>
     main = "Y~X vztah",  # <8>
     sub = Sys.Date()) # <9>
legend(x = "topright", # <10> 
       fill = "#4a6777", # <11>
       pch = 21, # <12>
       legend = c("Y"), # <13> 
       box.col = NA, # <14>
       lty = 1, # <15>
       col = "gray10") # <16>
```
1. Základní proměnné $X$ a $Y$ pro typ grafu.
2. Volba typu grafu `"b"` označuje body protnuté spojnicí.
3. Volba barvy popředí znaku bod/přímka.
4. Volba charakteru bodového znaku.
5. Volba barvy pozadí znaku umožňujícího výplň - bod.
6. Změna rozsahu osy $y$.
7. Změna názvu os.
8. Znění hlavního nadpisu.
9. Podnadpis *dtto*.
10. Pokračujeme nastavením umístění legendy.
11. Výplň prvku v legendě.
12. Typ prvku v legendě.
13. Název prvku v legendě.
14. Volba barvy ohraničení legendy
15. Volba typu spojnice (1 = plná čára)
16. Volba barvy popředí prvku legendy



```{r, fig.align='center'}
with(data = dfr, # <1>
     expr = { # <2>
       plot(x = X, y = Y)  # <2>
       lines(x = X, y = Y) # <2>
       }# <2>
     ) 
```
1. Funkce `with()` umožňuje zavolání funkce uvedené v arugmentu `expr` na proměnných v `data.frame`. Odpadá opakované psaní prefixu datové sady (zde `dfr$___`)
2. Argument `expr` může obsahovat i blok kódu `{...}`

::: callout-tip
## Úloha

6.  následujícím příkladu vytvoříte graf **Budykovy křivky**. \
Postup:\
    a) Nahrajte do prostředí data ze souboru.\           
    b) Začněte tvorbu grafu s funkcí `plot.new()`\           
    c) Nejjednodušší vztah popsal Schreiber v roce 1902\           
$$
  \dfrac{\textrm{Ea}}{\textrm{P}_a} = 1-\exp(-\phi)
$$
    d) Vytvořte posloupnost \phi od $0$ do $2$ s krokem $10e^{-3}$.\           
    e) S pomocí 
    f) Nastavte `xlab = "Ep/P"`, `ylab = "P/Er"`, `xlim` v rozsahu $\phi$ a `ylim` od $0$ do $1,2$.\           
  
  Výsledek by měl vypadat následovně:
```{r, echo=FALSE, fig.align='center'}
phi <- seq(0, 2, 10e-3)
schreiber <- 1 - exp(-phi)
plot(x = phi, 
     xlab = "Ep/P", 
     ylab = "P/Er", 
     xlim = c(0, 2), 
     ylim = c(0, 1.2), 
     # bty = "n",
     type = "n", 
     xaxt = "n",
     yaxt = "n"
)
# Add grid lines similar to gnuplot
grid(nx = 4, 
     ny = NULL, 
     col = "gray", 
     lty = "dotted", 
     lwd = 1)

# Ensure the plot has a gnuplot-like minimalist style
box(col = NA)  # Remove the box around the plot
axis(1, 
      col = "black", 
      col.ticks = "black", 
      lwd.ticks = 1, 
      lwd = 1, 
      las = 1, 
      tck = -0.02)  # X-axis
axis(2, 
     col = "black", 
     col.ticks = "black", 
     lwd.ticks = 1, 
     lwd = 1, 
     las = 1, 
     tck = -0.02)  # Y-axis

lines(x = phi, 
      y = schreiber, lty = 3)
segments(x0 = 0, x1 = 1, y0 = 0, y1 = 1, lwd = 2, col = "gray60")
segments(x0 = 1, x1 = 2, y0 = 1, y1 = 1, lwd = 2, col = "gray60")
```
:::


### Transformace souřadnic

S polárními souřadnicemi se setkáváme poměrně často. 

Polární souřadnice
$$
\begin{array}{rl}
x =& \sqrt{t}\cdot\cos(2\pi t)\\
y =& \sqrt{t}\cdot\sin(2\pi t)
\end{array}
$$

```{r}
x <- sqrt
```


## Volba barev

Výpis všech předdefinovaných barev[^03_grafy-1] lze získat příkazem `colors()`.

[^03_grafy-1]: Předdefinovaných barev je celkem 657.

```{r}
colors()[1:10]
```

### `RColorBrewer`

Součástí základní sady je balíček `RColorBrewer`

```{r, fig.align='center'}
#| fig-width: 10
#| fig-height: 8
RColorBrewer::display.brewer.all()
```

K vytvoření palety barev

```{r}
RColorBrewer::brewer.pal(100, name = "RdBu")
rbind(
  rainbow = rainbow(10),
  heat.colors = heat.colors(10),
  cm.colors = cm.colors(10),
  blues9
)


```


```{r}
palette.pals()
palette.colors(palette = "Okabe-Ito")

```

```{r}
fcol <- colorRampPalette(colors = c("black", "white"))
palette("Classic Tableau")
```


::: callout-note
## Poznámka

Správná volba barev v grafech odborných publikací je velmi důležitá. V ideálním 
případě by grafické škály měly být stejné čitelné jak pro lidi s poruchou barevného
spektra, tak v černobílem tisku. Obojí je řešeno například pomocí balíčku `scico` @pedersen2021package. 
Ve zkratce je problematika vysvětlena  například ve [vignette](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) balíčku `viridis`.
:::


## Matematická sazba v grafech

`?plotmath`
demo(plotmath)

## Layout

Jednoduchý pravidelný layout můžeme vytvořit změnou parametrů okna grafického výstupu pomocí funkce `par()`

### Sazba pomocí `par()`

```{r,fig.align='center'}
par(mfrow = c(1, 2)) #<1>
hist(dfr$X, main = "X", xlab = "") # <2>
hist(dfr$Y, main = "Y", xlab = "") # <2>
```
1. Okno výstupu rozdělíme do dvou sloupců na jednom řádku.
2. Posléze voláme dva grafy, které postupně vyplní pole v daném okně.

### Sazba do matice s funkcí `layout()`

```{r,fig.align='center'}
par(cex = 2)
layout.show(
  layout(
    mat = matrix(
      data = c(2, 2, 0, #<1>
               1, 1, 3, #<1>
               1, 1, 3), #<1>
      nrow = 3, 
      ncol = 3, 
      byrow = TRUE))
)
```
1. Zde sdělujeme, že celkově bude pole rozděleno v poměru $3\times 3$ a $4\over9$ 
(levá dolní část) vyplní 1. graf.

Nyní vynecháme `layout.show()`, zavolámem jen layout() a postupně přiřadíme grafy 
k jednotlivým polím.

```{r}
layout(
    mat = matrix(
      data = c(2, 2, 0,
               1, 1, 3,
               1, 1, 3), 
      nrow = 3, 
      ncol = 3, 
      byrow = TRUE))
```

::: callout-tip
## Úloha

4. Vytvořte layout dle následujícího nákresu a vyplňte libovolnými rúznými typy grafů.

:::

## Uložení do souboru

Grafy je možné uložit externě, at už prostřednictvím dialogu v ***Plots*** > ***Export***,
nebo přímo ve skriptu. Formát lze volit mezi rastrovými \*.png, \*.jpeg, \*.tiff, \*.bmp, 
či vektorovými \*.eps, \*.svg, \*.pdf. 

```{r, eval=FALSE}
png("./budyko_kompozit.png", 
    width = 8, 
    height = 6, 
    units = "px", 
    res = 300)
...  #<1>
dev.off()
```
1. Standardním způsobem vytvořený diagram či layout.

::: callout-tip
## Úloha

5.  a) Vytvořte layout a uložte do souboru s pomocí funkce `pdf()`. Využijte naápovědy.
    b) Vytvořte poslouponost `t <- seq(from = 2010, to = 2020, length = 200))` a potom
    do stejného grafu vyneste $\sin(2\pi(t - 1))$ a $\cos^2(2\pi t)$.
:::





```{r}
load("./data/data4chapter5and6.rda")
meanEPmon <- -1.55 + 0.96 * (8.128 + 0.457*meanTmon)*meanSImon
meanEPmon[meanEPmon < 0] <- 0
PET <- 365.25 * apply(meanEPmon, 1, mean, na.rm = TRUE)
# PETovP <- 
```

